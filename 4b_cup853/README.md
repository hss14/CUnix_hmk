##**1. 问题描述**
  
3个杯子，容量分别为8ml、5ml、3ml，今8ml的杯子装满了水，而另外两个是空的。         
在不用其他工具的情况下，怎样操作，可以将这8ml水精确地分为两个4ml？        
用计算机求解，使得倒水次数最少。
  
  
  
##**2. 设计思路**  
  
这是一个典型的广度优先遍历的问题。对根结点为`800`的六叉树（每个结点的后续结点有6种可能）BFS，直到找到`440`结点。         
        
但问题可以简化。        
-   每个结点事实上的孩子数远小于6：
    -   不是每种倒法都可以，必须前杯有水+后杯有空
    -   为使次数最少，之前出现过的组合可以直接剪枝
-   用链表（程序中实际使用了变长数组以简化）存储每个出现过的组合，对每个结点所有可能的后续组合查找该表，只把没出现过的组合对应的结点作为孩子结点，并把该组合记入链表。
-   BFS 通过队列实现。最初队列中只有根结点。每次出队1个结点并将其简化后的所有孩子结点入队。
-   并不需要真正存储这个6叉树结构，只需要找到`440`结点时能回溯即可，所以我们不存储每个结点的子结点而只存储其父结点，易回溯且大大简化程序，程序中实际上并没有树的数据结构。
-   这样带来的问题是，需要记录产生的每个结点，以便程序结束时free。然而我们发现，在实现 BFS 的队列时，使用 “变长数组 +`head`数组索引 +`tail`数组索引” 的方式，而不是真的把出队结点释放，就相当于记录了所有曾经产生过的结点，程序结束时只需要依次释放数组从 0 到`tail`索引的结点即可。
        
        
为使结构清晰，本程序分成了很多个小函数，具体可参见头文件中的注释，在此就不赘述了。

  
  
  
##**3.编译与测试**  
    
`make all`：编译方法  
  
  
`make test`：测试方法  
  
