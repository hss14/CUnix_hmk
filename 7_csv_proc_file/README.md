##**1. 问题描述**

将作业6改为多进程：

+ 父进程： 
    - 将文本文件按行拆分为若干小文件
    - 等待所有子进程退出后，将小二进制文件拼接成完整的文件
+ 每个子进程： 转换一个小文件的格式到二进制，退出


##**2. 设计思路**

本作业在第6次作业的基础上完成，因此与作业6相同的部分将不再赘述。


```c
int child_csv2bin( const char *csvsplit, const char *binsplit, const char *badrecords);
//将名为`csvsplit`的csv文件转换为名为`binsplit`的二进制文件， 不合法的记录及产生的错误信息写入名为`badrecords`的文件
```
子进程调用该函数处理小文件。该函数与作业6中的文件转换函数大致相同，只是没有(1)忽略csv文件第一行 及(2)检查csv文件每一行是否超长（父进程在分割csv文件时已进行这两步）。



```c
#define SplitSize 5
#define DirectoryTmp "tmp/"
```
定义每`SplitSize`行记录分割为一个小csv文件。因为测试样例很小，所以这里暂定义为一个小数字5.
整洁起见，所有父进程分割出的小csv文件、子进程对它们处理产生的二进制小文件都放在目录`DirectoryTmp`下。若在`make`时定义参数`-DCLEARUP`，则程序会在退出前自动清除该文件夹。



```c
int csv2bin( const char *filecsv, const char *filebin );
// 将名为`csvsplit`的csv文件转换为名为`binsplit`的二进制文件
```
本次作业的主体部分。
父进程首先对原csv文件的每一行进行预处理。舍弃第一行及超长的行，将长度不超过`MaxLine`的行写入分割后的小csv文件中。小文件的命名依次为参数`filecsv`加后缀`.1`、`.2`，等等。
每写`Splitize`行就结束写该小csv文件并`fork`，父进程继续预处理原csv文件，写入新建的下一个小csv文件中。而子进程调用前述`child_csv2bin`函数对该小文件处理。处理后的二进制文件名依次相应为参数`filebin`加后缀`.1`、`.2`，等等。
父进程用一个队列`childlist`依次记录每个子进程的进程号，顺序与小文件名的顺序相对应。
父进程完成预处理工作后，进行最后一步——合并子二进制文件到总二进制文件中。父进程按`childlist`中记载的顺序依次`waitpid`子进程，若该子进程正常退出没有错误，则首先读取该子文件中第一个数据项——记录数，叠加到总记录数计数器上，然后把子文件中的剩余内容一次性附加到总二进制文件中。最后更新总二进制文件的第一个数据项——总记录数。
如果定义了`CLEARUP`宏，则在最后递归清理`DirectoryTmp`文件夹。



```c
void addlist( pid_t pid, struct pidlist **head);
pid_t pop( struct pidlist **head);
```
为上述过程中用于处理`childlist`队列的小函数。


#####**关于进程学到的**

-   本次作业父子进程间通信使用的是最原始的用文件通信，较为简单，当然读写用于通信的中间子文件会导致总速度变慢。
-   `fork`前需要`fflush`文件缓冲区，否则每次`fork`后文件缓冲区的内容都被复制了一份。即使子进程完全没对该文件和该文件指针进行操作，每个进程退出时缓冲区的内容都会被`fflush`到文件中，造成文件中有多条重复记录。
-   `"a"`方式打开文件时，文件指针在每次写操作前会被原子地自动定位到当前文件尾，即使写操作前`fseek`到文件头也毫无用处。当多个进程写同一文件时，用`"a"`打开文件可保证每个进程写的内容不会被互相覆盖产生冲突。但是，在本程序中，设计二进制文件的格式为第一个数据项为本文件记录数，在写完整个文件后要`fseek`到开头更新该数据项，而每个进程都是独立写各自的文件不会产生冲突，所以必须用`"w"`而不可以用`"a"`打开。


##**3.编译与测试**
`make all`：编译方法

`make test`：测试样例及测试方法说明