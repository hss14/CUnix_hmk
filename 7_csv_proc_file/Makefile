CFILES = $(wildcard *.c)
OBJS = $(CFILES:.c=.o)
CC = gcc
CFLAGS = -Wall -g #-DCLEARUP #-DHSSDEBUG

all: csv7

csv7: $(OBJS)
	$(CC) $(CFALGS) -o $@ $^

%.o : %.c 
	$(CC) $(CFLAGS) -c -o $@ $^

.PHONY: clean
clean: $(OBJS) csv7 
	rm $^

.PHONY: clean-intermediate	
# ========== remove all the intermediate files remained from the last test
clean-intermediate: $(wildcard *.err) $(wildcard *.long) $(wildcard *.bin) $(wildcard *.log) 
	rm -r tmp/

.PHONY: test
test:
	# example of legal augments:
	#
	#
	#
	# ================ transform contents of "name_of_csv_file" to "name_of_bin_file" ===============
	# 	./csv7 t name_of_csv_file name_of_bin_file     
	make clean-intermediate
	./csv7 t test.csv test.bin 
	# 	
	# for more information and details, check:
	# 	"test.csv": 
	# 		==> the original csv file
	# 	"tmp/test.csv.i"(i=1,2,...): 
	# 		==> split csv files generated by parent process
	# 	"tmp/test.bin.i"(i=1,2,...): 
	# 		==> corresponding split bin files transformed by corresponding child process
	# 	"test.bin": 
	# 		==> the final tranformed bin file merged by parent process
	# 	"test.csv.long": 
	# 		==> records(line) too long of csv file "test.csv", all discarded for result
	# 	"test.csv.err": 
	# 		==> illegal records, some discarded while others truncated; also log all the other errors occured
	#
	# to keep things tidy, use -DCLEARUP when make (refer to "CFLAGS": line 4) to clear up directory tmp/ automatically 
	# under this circumstance:
	# 1. do not "rm -r tmp/" manually, otherwise an error will occur
	# 2. cannot check nor use "csv7 p" to print out tmp/test.bin.1(2,3..) or tmp/test.csv.1(2,3...) 
	# 
	#
	#
	# ============ print out contents of each bin file: "name_of_bin_file"(s) ============
	# 	./csv7 p name_of_bin_file(s) 
	./csv7 p test.bin tmp/test.bin.1 tmp/test.bin.2
